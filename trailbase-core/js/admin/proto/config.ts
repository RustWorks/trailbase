// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.21.12
// source: config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "config";

export enum OAuthProviderId {
  OAUTH_PROVIDER_ID_UNDEFINED = 0,
  TEST = 1,
  OIDC0 = 2,
  DISCORD = 10,
  GITLAB = 11,
  GOOGLE = 12,
  FACEBOOK = 13,
  MICROSOFT = 14,
  UNRECOGNIZED = -1,
}

export function oAuthProviderIdFromJSON(object: any): OAuthProviderId {
  switch (object) {
    case 0:
    case "OAUTH_PROVIDER_ID_UNDEFINED":
      return OAuthProviderId.OAUTH_PROVIDER_ID_UNDEFINED;
    case 1:
    case "TEST":
      return OAuthProviderId.TEST;
    case 2:
    case "OIDC0":
      return OAuthProviderId.OIDC0;
    case 10:
    case "DISCORD":
      return OAuthProviderId.DISCORD;
    case 11:
    case "GITLAB":
      return OAuthProviderId.GITLAB;
    case 12:
    case "GOOGLE":
      return OAuthProviderId.GOOGLE;
    case 13:
    case "FACEBOOK":
      return OAuthProviderId.FACEBOOK;
    case 14:
    case "MICROSOFT":
      return OAuthProviderId.MICROSOFT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OAuthProviderId.UNRECOGNIZED;
  }
}

export function oAuthProviderIdToJSON(object: OAuthProviderId): string {
  switch (object) {
    case OAuthProviderId.OAUTH_PROVIDER_ID_UNDEFINED:
      return "OAUTH_PROVIDER_ID_UNDEFINED";
    case OAuthProviderId.TEST:
      return "TEST";
    case OAuthProviderId.OIDC0:
      return "OIDC0";
    case OAuthProviderId.DISCORD:
      return "DISCORD";
    case OAuthProviderId.GITLAB:
      return "GITLAB";
    case OAuthProviderId.GOOGLE:
      return "GOOGLE";
    case OAuthProviderId.FACEBOOK:
      return "FACEBOOK";
    case OAuthProviderId.MICROSOFT:
      return "MICROSOFT";
    case OAuthProviderId.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SystemCronJobId {
  SYSTEM_CRON_JOB_ID_UNDEFINED = 0,
  BACKUP = 1,
  HEARTBEAT = 2,
  LOG_CLEANER = 3,
  AUTH_CLEANER = 4,
  QUERY_OPTIMIZER = 5,
  UNRECOGNIZED = -1,
}

export function systemCronJobIdFromJSON(object: any): SystemCronJobId {
  switch (object) {
    case 0:
    case "SYSTEM_CRON_JOB_ID_UNDEFINED":
      return SystemCronJobId.SYSTEM_CRON_JOB_ID_UNDEFINED;
    case 1:
    case "BACKUP":
      return SystemCronJobId.BACKUP;
    case 2:
    case "HEARTBEAT":
      return SystemCronJobId.HEARTBEAT;
    case 3:
    case "LOG_CLEANER":
      return SystemCronJobId.LOG_CLEANER;
    case 4:
    case "AUTH_CLEANER":
      return SystemCronJobId.AUTH_CLEANER;
    case 5:
    case "QUERY_OPTIMIZER":
      return SystemCronJobId.QUERY_OPTIMIZER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SystemCronJobId.UNRECOGNIZED;
  }
}

export function systemCronJobIdToJSON(object: SystemCronJobId): string {
  switch (object) {
    case SystemCronJobId.SYSTEM_CRON_JOB_ID_UNDEFINED:
      return "SYSTEM_CRON_JOB_ID_UNDEFINED";
    case SystemCronJobId.BACKUP:
      return "BACKUP";
    case SystemCronJobId.HEARTBEAT:
      return "HEARTBEAT";
    case SystemCronJobId.LOG_CLEANER:
      return "LOG_CLEANER";
    case SystemCronJobId.AUTH_CLEANER:
      return "AUTH_CLEANER";
    case SystemCronJobId.QUERY_OPTIMIZER:
      return "QUERY_OPTIMIZER";
    case SystemCronJobId.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * / Sqlite specific (as opposed to standard SQL) constrained-violation
 * / resolution strategy upon insert.
 */
export enum ConflictResolutionStrategy {
  CONFLICT_RESOLUTION_STRATEGY_UNDEFINED = 0,
  /** ABORT - / SQL default: Keep transaction open and abort the current statement. */
  ABORT = 1,
  /** ROLLBACK - / Abort entire transaction. */
  ROLLBACK = 2,
  /**
   * FAIL - / Similar to Abort but doesn't roll back the current statement, i.e. if the
   * / current statement affects multiple rows, changes by that statement prior
   * / to the failure are not rolled back.
   */
  FAIL = 3,
  /** IGNORE - / Skip the statement and continue. */
  IGNORE = 4,
  /**
   * REPLACE - / Replaces the conflicting row in case of a collision (e.g. unique
   * / constraint).
   */
  REPLACE = 5,
  UNRECOGNIZED = -1,
}

export function conflictResolutionStrategyFromJSON(object: any): ConflictResolutionStrategy {
  switch (object) {
    case 0:
    case "CONFLICT_RESOLUTION_STRATEGY_UNDEFINED":
      return ConflictResolutionStrategy.CONFLICT_RESOLUTION_STRATEGY_UNDEFINED;
    case 1:
    case "ABORT":
      return ConflictResolutionStrategy.ABORT;
    case 2:
    case "ROLLBACK":
      return ConflictResolutionStrategy.ROLLBACK;
    case 3:
    case "FAIL":
      return ConflictResolutionStrategy.FAIL;
    case 4:
    case "IGNORE":
      return ConflictResolutionStrategy.IGNORE;
    case 5:
    case "REPLACE":
      return ConflictResolutionStrategy.REPLACE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConflictResolutionStrategy.UNRECOGNIZED;
  }
}

export function conflictResolutionStrategyToJSON(object: ConflictResolutionStrategy): string {
  switch (object) {
    case ConflictResolutionStrategy.CONFLICT_RESOLUTION_STRATEGY_UNDEFINED:
      return "CONFLICT_RESOLUTION_STRATEGY_UNDEFINED";
    case ConflictResolutionStrategy.ABORT:
      return "ABORT";
    case ConflictResolutionStrategy.ROLLBACK:
      return "ROLLBACK";
    case ConflictResolutionStrategy.FAIL:
      return "FAIL";
    case ConflictResolutionStrategy.IGNORE:
      return "IGNORE";
    case ConflictResolutionStrategy.REPLACE:
      return "REPLACE";
    case ConflictResolutionStrategy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PermissionFlag {
  PERMISSION_FLAG_UNDEFINED = 0,
  /** CREATE - Database record insert. */
  CREATE = 1,
  /** READ - Database record read/list, i.e. select. */
  READ = 2,
  /** UPDATE - Database record update. */
  UPDATE = 4,
  /** DELETE - Database record delete. */
  DELETE = 8,
  /** SCHEMA - / Lookup JSON schema for the given record api . */
  SCHEMA = 16,
  UNRECOGNIZED = -1,
}

export function permissionFlagFromJSON(object: any): PermissionFlag {
  switch (object) {
    case 0:
    case "PERMISSION_FLAG_UNDEFINED":
      return PermissionFlag.PERMISSION_FLAG_UNDEFINED;
    case 1:
    case "CREATE":
      return PermissionFlag.CREATE;
    case 2:
    case "READ":
      return PermissionFlag.READ;
    case 4:
    case "UPDATE":
      return PermissionFlag.UPDATE;
    case 8:
    case "DELETE":
      return PermissionFlag.DELETE;
    case 16:
    case "SCHEMA":
      return PermissionFlag.SCHEMA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PermissionFlag.UNRECOGNIZED;
  }
}

export function permissionFlagToJSON(object: PermissionFlag): string {
  switch (object) {
    case PermissionFlag.PERMISSION_FLAG_UNDEFINED:
      return "PERMISSION_FLAG_UNDEFINED";
    case PermissionFlag.CREATE:
      return "CREATE";
    case PermissionFlag.READ:
      return "READ";
    case PermissionFlag.UPDATE:
      return "UPDATE";
    case PermissionFlag.DELETE:
      return "DELETE";
    case PermissionFlag.SCHEMA:
      return "SCHEMA";
    case PermissionFlag.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface EmailTemplate {
  subject?: string | undefined;
  body?: string | undefined;
}

export interface EmailConfig {
  smtpHost?: string | undefined;
  smtpPort?: number | undefined;
  smtpUsername?: string | undefined;
  smtpPassword?: string | undefined;
  senderName?: string | undefined;
  senderAddress?: string | undefined;
  userVerificationTemplate?: EmailTemplate | undefined;
  passwordResetTemplate?: EmailTemplate | undefined;
  changeEmailTemplate?: EmailTemplate | undefined;
}

export interface OAuthProviderConfig {
  clientId?: string | undefined;
  clientSecret?: string | undefined;
  providerId?:
    | OAuthProviderId
    | undefined;
  /**
   * Settings for generic OpenID Connect provider. Name is implicitly provided
   * via the `AuthConfig.oauth_provders` map key.
   */
  displayName?: string | undefined;
  authUrl?: string | undefined;
  tokenUrl?: string | undefined;
  userApiUrl?: string | undefined;
}

export interface AuthConfig {
  authTokenTtlSec?: number | undefined;
  refreshTokenTtlSec?: number | undefined;
  oauthProviders: { [key: string]: OAuthProviderConfig };
}

export interface AuthConfig_OauthProvidersEntry {
  key: string;
  value: OAuthProviderConfig | undefined;
}

export interface S3StorageConfig {
  endpoint?: string | undefined;
  region?: string | undefined;
  bucketName?:
    | string
    | undefined;
  /** / S3 access key, a.k.a. username. */
  accessKey?:
    | string
    | undefined;
  /** / S3 secret access key, a.k.a. password. */
  secretAccessKey?: string | undefined;
}

export interface ServerConfig {
  /**
   * / Application name presented to users, e.g. when sending emails. Default:
   * / "TrailBase".
   */
  applicationName?:
    | string
    | undefined;
  /**
   * / Your final, deployed URL. This url is used to build canonical urls
   * / for emails, OAuth redirects, ... . Default: "http://localhost:4000".
   */
  siteUrl?:
    | string
    | undefined;
  /**
   * /  Max age of logs that will be retained during period logs cleanup. Note
   * /  that this implies that some older logs may persist until the cleanup job
   * /  reruns. Default: 7 days.
   */
  logsRetentionSec?:
    | number
    | undefined;
  /**
   * / Interval at which backups are persisted. Setting it to 0 will disable
   * / backups. Default: 0.
   */
  backupIntervalSec?:
    | number
    | undefined;
  /** / If present will use S3 setup over local file-system based storage. */
  s3StorageConfig?: S3StorageConfig | undefined;
}

export interface SystemCronJob {
  /** / Identifies the system cron job by its id. */
  id?:
    | SystemCronJobId
    | undefined;
  /** / Cron spec (sec, min, hour, day of month, month, day of week, year). */
  spec?:
    | string
    | undefined;
  /** / Disable the system job. */
  disableJob?: boolean | undefined;
}

export interface CronConfig {
  /**
   * / System jobs overrides.
   * /
   * / NOTE: This is technically a map from id to config, however enums are not
   * / allowed as map keys.
   */
  systemJobs: SystemCronJob[];
}

export interface RecordApiConfig {
  /** / API name, i.e. unique name used to access data via HTTP. */
  name?:
    | string
    | undefined;
  /** / Referenced table to be exposed. */
  tableName?:
    | string
    | undefined;
  /** / Strategy to be used on insert if a table constraint is violated. */
  conflictResolution?:
    | ConflictResolutionStrategy
    | undefined;
  /**
   * / Fill columns referencing _user(id) automatically from current user's
   * / authentication context if present. Can be useful for static clients, such
   * / as HTML forms, otherwise it's recommended to have the client provide user
   * / ids explicitly and to keep this feature off.
   */
  autofillMissingUserIdColumns?:
    | boolean
    | undefined;
  /**
   * / Allow subscribing to data changes in realtime using SSE streaming.
   * /
   * / NOTE: If you're using a reverse proxy, this will likely require
   * / configuration changes to allow for server-side streaming HTTP, e.g.
   * / tell the proxy to keep listening and not cache.
   */
  enableSubscriptions?:
    | boolean
    | undefined;
  /** / Access control lists. */
  aclWorld: PermissionFlag[];
  aclAuthenticated: PermissionFlag[];
  /**
   * / Access rules to be evaluated on request. Expected to be valid SQL
   * / expression, where `SELECT <expr>` returns a unary boolean.
   * /
   * / The evaluator injects _USER_, _ROW_ and _REQ_ tables that can be
   * / used for validating access, e.g.:
   * /
   * /   _USER_.id = _REQ_.owner
   * /
   * / ensures that the value provided for the `owner` column during an insert
   * / matches the current authenticated user's id. One can also construct
   * / arbitrary validations including sub-queries, e.g.:
   * /
   * /   _USER_.id = _REQ_.owner AND EXISTS(SELECT FROM allowed WHERE allowed.user = _USER_.id)
   */
  createAccessRule?: string | undefined;
  readAccessRule?: string | undefined;
  updateAccessRule?: string | undefined;
  deleteAccessRule?: string | undefined;
  schemaAccessRule?:
    | string
    | undefined;
  /**
   * / A list of foreign key columns that can be expanded on read/list, i.e. the
   * / foreign record will be inlined into the response.
   * /
   * / Only columns and foreign tables with names not starting with "_", i.e. are
   * / allowed to be expanded.
   */
  expand: string[];
}

export interface JsonSchemaConfig {
  name?: string | undefined;
  schema?: string | undefined;
}

export interface Config {
  /**
   * NOTE: These top-level fields currently have to be `required` due to the
   * overly simple approach on how we do config merging (from env vars and
   * vault).
   */
  email: EmailConfig | undefined;
  server: ServerConfig | undefined;
  auth: AuthConfig | undefined;
  cron: CronConfig | undefined;
  recordApis: RecordApiConfig[];
  schemas: JsonSchemaConfig[];
}

function createBaseEmailTemplate(): EmailTemplate {
  return {};
}

export const EmailTemplate: MessageFns<EmailTemplate> = {
  encode(message: EmailTemplate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== undefined && message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.body !== undefined && message.body !== "") {
      writer.uint32(18).string(message.body);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmailTemplate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmailTemplate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmailTemplate {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : undefined,
      body: isSet(object.body) ? globalThis.String(object.body) : undefined,
    };
  },

  toJSON(message: EmailTemplate): unknown {
    const obj: any = {};
    if (message.subject !== undefined && message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.body !== undefined && message.body !== "") {
      obj.body = message.body;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmailTemplate>, I>>(base?: I): EmailTemplate {
    return EmailTemplate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmailTemplate>, I>>(object: I): EmailTemplate {
    const message = createBaseEmailTemplate();
    message.subject = object.subject ?? "";
    message.body = object.body ?? "";
    return message;
  },
};

function createBaseEmailConfig(): EmailConfig {
  return {};
}

export const EmailConfig: MessageFns<EmailConfig> = {
  encode(message: EmailConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.smtpHost !== undefined && message.smtpHost !== "") {
      writer.uint32(10).string(message.smtpHost);
    }
    if (message.smtpPort !== undefined && message.smtpPort !== 0) {
      writer.uint32(16).uint32(message.smtpPort);
    }
    if (message.smtpUsername !== undefined && message.smtpUsername !== "") {
      writer.uint32(26).string(message.smtpUsername);
    }
    if (message.smtpPassword !== undefined && message.smtpPassword !== "") {
      writer.uint32(34).string(message.smtpPassword);
    }
    if (message.senderName !== undefined && message.senderName !== "") {
      writer.uint32(90).string(message.senderName);
    }
    if (message.senderAddress !== undefined && message.senderAddress !== "") {
      writer.uint32(98).string(message.senderAddress);
    }
    if (message.userVerificationTemplate !== undefined) {
      EmailTemplate.encode(message.userVerificationTemplate, writer.uint32(170).fork()).join();
    }
    if (message.passwordResetTemplate !== undefined) {
      EmailTemplate.encode(message.passwordResetTemplate, writer.uint32(178).fork()).join();
    }
    if (message.changeEmailTemplate !== undefined) {
      EmailTemplate.encode(message.changeEmailTemplate, writer.uint32(186).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmailConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmailConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.smtpHost = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.smtpPort = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.smtpUsername = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.smtpPassword = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.senderName = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.senderAddress = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.userVerificationTemplate = EmailTemplate.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.passwordResetTemplate = EmailTemplate.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.changeEmailTemplate = EmailTemplate.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EmailConfig {
    return {
      smtpHost: isSet(object.smtpHost) ? globalThis.String(object.smtpHost) : undefined,
      smtpPort: isSet(object.smtpPort) ? globalThis.Number(object.smtpPort) : undefined,
      smtpUsername: isSet(object.smtpUsername) ? globalThis.String(object.smtpUsername) : undefined,
      smtpPassword: isSet(object.smtpPassword) ? globalThis.String(object.smtpPassword) : undefined,
      senderName: isSet(object.senderName) ? globalThis.String(object.senderName) : undefined,
      senderAddress: isSet(object.senderAddress) ? globalThis.String(object.senderAddress) : undefined,
      userVerificationTemplate: isSet(object.userVerificationTemplate)
        ? EmailTemplate.fromJSON(object.userVerificationTemplate)
        : undefined,
      passwordResetTemplate: isSet(object.passwordResetTemplate)
        ? EmailTemplate.fromJSON(object.passwordResetTemplate)
        : undefined,
      changeEmailTemplate: isSet(object.changeEmailTemplate)
        ? EmailTemplate.fromJSON(object.changeEmailTemplate)
        : undefined,
    };
  },

  toJSON(message: EmailConfig): unknown {
    const obj: any = {};
    if (message.smtpHost !== undefined && message.smtpHost !== "") {
      obj.smtpHost = message.smtpHost;
    }
    if (message.smtpPort !== undefined && message.smtpPort !== 0) {
      obj.smtpPort = Math.round(message.smtpPort);
    }
    if (message.smtpUsername !== undefined && message.smtpUsername !== "") {
      obj.smtpUsername = message.smtpUsername;
    }
    if (message.smtpPassword !== undefined && message.smtpPassword !== "") {
      obj.smtpPassword = message.smtpPassword;
    }
    if (message.senderName !== undefined && message.senderName !== "") {
      obj.senderName = message.senderName;
    }
    if (message.senderAddress !== undefined && message.senderAddress !== "") {
      obj.senderAddress = message.senderAddress;
    }
    if (message.userVerificationTemplate !== undefined) {
      obj.userVerificationTemplate = EmailTemplate.toJSON(message.userVerificationTemplate);
    }
    if (message.passwordResetTemplate !== undefined) {
      obj.passwordResetTemplate = EmailTemplate.toJSON(message.passwordResetTemplate);
    }
    if (message.changeEmailTemplate !== undefined) {
      obj.changeEmailTemplate = EmailTemplate.toJSON(message.changeEmailTemplate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EmailConfig>, I>>(base?: I): EmailConfig {
    return EmailConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmailConfig>, I>>(object: I): EmailConfig {
    const message = createBaseEmailConfig();
    message.smtpHost = object.smtpHost ?? "";
    message.smtpPort = object.smtpPort ?? 0;
    message.smtpUsername = object.smtpUsername ?? "";
    message.smtpPassword = object.smtpPassword ?? "";
    message.senderName = object.senderName ?? "";
    message.senderAddress = object.senderAddress ?? "";
    message.userVerificationTemplate =
      (object.userVerificationTemplate !== undefined && object.userVerificationTemplate !== null)
        ? EmailTemplate.fromPartial(object.userVerificationTemplate)
        : undefined;
    message.passwordResetTemplate =
      (object.passwordResetTemplate !== undefined && object.passwordResetTemplate !== null)
        ? EmailTemplate.fromPartial(object.passwordResetTemplate)
        : undefined;
    message.changeEmailTemplate = (object.changeEmailTemplate !== undefined && object.changeEmailTemplate !== null)
      ? EmailTemplate.fromPartial(object.changeEmailTemplate)
      : undefined;
    return message;
  },
};

function createBaseOAuthProviderConfig(): OAuthProviderConfig {
  return {};
}

export const OAuthProviderConfig: MessageFns<OAuthProviderConfig> = {
  encode(message: OAuthProviderConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== undefined && message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.clientSecret !== undefined && message.clientSecret !== "") {
      writer.uint32(18).string(message.clientSecret);
    }
    if (message.providerId !== undefined && message.providerId !== 0) {
      writer.uint32(24).int32(message.providerId);
    }
    if (message.displayName !== undefined && message.displayName !== "") {
      writer.uint32(90).string(message.displayName);
    }
    if (message.authUrl !== undefined && message.authUrl !== "") {
      writer.uint32(98).string(message.authUrl);
    }
    if (message.tokenUrl !== undefined && message.tokenUrl !== "") {
      writer.uint32(106).string(message.tokenUrl);
    }
    if (message.userApiUrl !== undefined && message.userApiUrl !== "") {
      writer.uint32(114).string(message.userApiUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OAuthProviderConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOAuthProviderConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientSecret = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.providerId = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.authUrl = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.tokenUrl = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.userApiUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OAuthProviderConfig {
    return {
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : undefined,
      clientSecret: isSet(object.clientSecret) ? globalThis.String(object.clientSecret) : undefined,
      providerId: isSet(object.providerId) ? oAuthProviderIdFromJSON(object.providerId) : undefined,
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : undefined,
      authUrl: isSet(object.authUrl) ? globalThis.String(object.authUrl) : undefined,
      tokenUrl: isSet(object.tokenUrl) ? globalThis.String(object.tokenUrl) : undefined,
      userApiUrl: isSet(object.userApiUrl) ? globalThis.String(object.userApiUrl) : undefined,
    };
  },

  toJSON(message: OAuthProviderConfig): unknown {
    const obj: any = {};
    if (message.clientId !== undefined && message.clientId !== "") {
      obj.clientId = message.clientId;
    }
    if (message.clientSecret !== undefined && message.clientSecret !== "") {
      obj.clientSecret = message.clientSecret;
    }
    if (message.providerId !== undefined && message.providerId !== 0) {
      obj.providerId = oAuthProviderIdToJSON(message.providerId);
    }
    if (message.displayName !== undefined && message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.authUrl !== undefined && message.authUrl !== "") {
      obj.authUrl = message.authUrl;
    }
    if (message.tokenUrl !== undefined && message.tokenUrl !== "") {
      obj.tokenUrl = message.tokenUrl;
    }
    if (message.userApiUrl !== undefined && message.userApiUrl !== "") {
      obj.userApiUrl = message.userApiUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OAuthProviderConfig>, I>>(base?: I): OAuthProviderConfig {
    return OAuthProviderConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OAuthProviderConfig>, I>>(object: I): OAuthProviderConfig {
    const message = createBaseOAuthProviderConfig();
    message.clientId = object.clientId ?? "";
    message.clientSecret = object.clientSecret ?? "";
    message.providerId = object.providerId ?? 0;
    message.displayName = object.displayName ?? "";
    message.authUrl = object.authUrl ?? "";
    message.tokenUrl = object.tokenUrl ?? "";
    message.userApiUrl = object.userApiUrl ?? "";
    return message;
  },
};

function createBaseAuthConfig(): AuthConfig {
  return { oauthProviders: {} };
}

export const AuthConfig: MessageFns<AuthConfig> = {
  encode(message: AuthConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authTokenTtlSec !== undefined && message.authTokenTtlSec !== 0) {
      writer.uint32(8).int64(message.authTokenTtlSec);
    }
    if (message.refreshTokenTtlSec !== undefined && message.refreshTokenTtlSec !== 0) {
      writer.uint32(16).int64(message.refreshTokenTtlSec);
    }
    Object.entries(message.oauthProviders).forEach(([key, value]) => {
      AuthConfig_OauthProvidersEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.authTokenTtlSec = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.refreshTokenTtlSec = longToNumber(reader.int64());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          const entry11 = AuthConfig_OauthProvidersEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.oauthProviders[entry11.key] = entry11.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthConfig {
    return {
      authTokenTtlSec: isSet(object.authTokenTtlSec) ? globalThis.Number(object.authTokenTtlSec) : undefined,
      refreshTokenTtlSec: isSet(object.refreshTokenTtlSec) ? globalThis.Number(object.refreshTokenTtlSec) : undefined,
      oauthProviders: isObject(object.oauthProviders)
        ? Object.entries(object.oauthProviders).reduce<{ [key: string]: OAuthProviderConfig }>((acc, [key, value]) => {
          acc[key] = OAuthProviderConfig.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AuthConfig): unknown {
    const obj: any = {};
    if (message.authTokenTtlSec !== undefined && message.authTokenTtlSec !== 0) {
      obj.authTokenTtlSec = Math.round(message.authTokenTtlSec);
    }
    if (message.refreshTokenTtlSec !== undefined && message.refreshTokenTtlSec !== 0) {
      obj.refreshTokenTtlSec = Math.round(message.refreshTokenTtlSec);
    }
    if (message.oauthProviders) {
      const entries = Object.entries(message.oauthProviders);
      if (entries.length > 0) {
        obj.oauthProviders = {};
        entries.forEach(([k, v]) => {
          obj.oauthProviders[k] = OAuthProviderConfig.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthConfig>, I>>(base?: I): AuthConfig {
    return AuthConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthConfig>, I>>(object: I): AuthConfig {
    const message = createBaseAuthConfig();
    message.authTokenTtlSec = object.authTokenTtlSec ?? 0;
    message.refreshTokenTtlSec = object.refreshTokenTtlSec ?? 0;
    message.oauthProviders = Object.entries(object.oauthProviders ?? {}).reduce<{ [key: string]: OAuthProviderConfig }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = OAuthProviderConfig.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseAuthConfig_OauthProvidersEntry(): AuthConfig_OauthProvidersEntry {
  return { key: "", value: undefined };
}

export const AuthConfig_OauthProvidersEntry: MessageFns<AuthConfig_OauthProvidersEntry> = {
  encode(message: AuthConfig_OauthProvidersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      OAuthProviderConfig.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthConfig_OauthProvidersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthConfig_OauthProvidersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = OAuthProviderConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthConfig_OauthProvidersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? OAuthProviderConfig.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AuthConfig_OauthProvidersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = OAuthProviderConfig.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthConfig_OauthProvidersEntry>, I>>(base?: I): AuthConfig_OauthProvidersEntry {
    return AuthConfig_OauthProvidersEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthConfig_OauthProvidersEntry>, I>>(
    object: I,
  ): AuthConfig_OauthProvidersEntry {
    const message = createBaseAuthConfig_OauthProvidersEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? OAuthProviderConfig.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseS3StorageConfig(): S3StorageConfig {
  return {};
}

export const S3StorageConfig: MessageFns<S3StorageConfig> = {
  encode(message: S3StorageConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.endpoint !== undefined && message.endpoint !== "") {
      writer.uint32(10).string(message.endpoint);
    }
    if (message.region !== undefined && message.region !== "") {
      writer.uint32(18).string(message.region);
    }
    if (message.bucketName !== undefined && message.bucketName !== "") {
      writer.uint32(42).string(message.bucketName);
    }
    if (message.accessKey !== undefined && message.accessKey !== "") {
      writer.uint32(66).string(message.accessKey);
    }
    if (message.secretAccessKey !== undefined && message.secretAccessKey !== "") {
      writer.uint32(74).string(message.secretAccessKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): S3StorageConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseS3StorageConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.endpoint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bucketName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.accessKey = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.secretAccessKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): S3StorageConfig {
    return {
      endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : undefined,
      region: isSet(object.region) ? globalThis.String(object.region) : undefined,
      bucketName: isSet(object.bucketName) ? globalThis.String(object.bucketName) : undefined,
      accessKey: isSet(object.accessKey) ? globalThis.String(object.accessKey) : undefined,
      secretAccessKey: isSet(object.secretAccessKey) ? globalThis.String(object.secretAccessKey) : undefined,
    };
  },

  toJSON(message: S3StorageConfig): unknown {
    const obj: any = {};
    if (message.endpoint !== undefined && message.endpoint !== "") {
      obj.endpoint = message.endpoint;
    }
    if (message.region !== undefined && message.region !== "") {
      obj.region = message.region;
    }
    if (message.bucketName !== undefined && message.bucketName !== "") {
      obj.bucketName = message.bucketName;
    }
    if (message.accessKey !== undefined && message.accessKey !== "") {
      obj.accessKey = message.accessKey;
    }
    if (message.secretAccessKey !== undefined && message.secretAccessKey !== "") {
      obj.secretAccessKey = message.secretAccessKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<S3StorageConfig>, I>>(base?: I): S3StorageConfig {
    return S3StorageConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<S3StorageConfig>, I>>(object: I): S3StorageConfig {
    const message = createBaseS3StorageConfig();
    message.endpoint = object.endpoint ?? "";
    message.region = object.region ?? "";
    message.bucketName = object.bucketName ?? "";
    message.accessKey = object.accessKey ?? "";
    message.secretAccessKey = object.secretAccessKey ?? "";
    return message;
  },
};

function createBaseServerConfig(): ServerConfig {
  return {};
}

export const ServerConfig: MessageFns<ServerConfig> = {
  encode(message: ServerConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.applicationName !== undefined && message.applicationName !== "") {
      writer.uint32(10).string(message.applicationName);
    }
    if (message.siteUrl !== undefined && message.siteUrl !== "") {
      writer.uint32(18).string(message.siteUrl);
    }
    if (message.logsRetentionSec !== undefined && message.logsRetentionSec !== 0) {
      writer.uint32(88).int64(message.logsRetentionSec);
    }
    if (message.backupIntervalSec !== undefined && message.backupIntervalSec !== 0) {
      writer.uint32(96).int64(message.backupIntervalSec);
    }
    if (message.s3StorageConfig !== undefined) {
      S3StorageConfig.encode(message.s3StorageConfig, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.applicationName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.siteUrl = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.logsRetentionSec = longToNumber(reader.int64());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.backupIntervalSec = longToNumber(reader.int64());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.s3StorageConfig = S3StorageConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerConfig {
    return {
      applicationName: isSet(object.applicationName) ? globalThis.String(object.applicationName) : undefined,
      siteUrl: isSet(object.siteUrl) ? globalThis.String(object.siteUrl) : undefined,
      logsRetentionSec: isSet(object.logsRetentionSec) ? globalThis.Number(object.logsRetentionSec) : undefined,
      backupIntervalSec: isSet(object.backupIntervalSec) ? globalThis.Number(object.backupIntervalSec) : undefined,
      s3StorageConfig: isSet(object.s3StorageConfig) ? S3StorageConfig.fromJSON(object.s3StorageConfig) : undefined,
    };
  },

  toJSON(message: ServerConfig): unknown {
    const obj: any = {};
    if (message.applicationName !== undefined && message.applicationName !== "") {
      obj.applicationName = message.applicationName;
    }
    if (message.siteUrl !== undefined && message.siteUrl !== "") {
      obj.siteUrl = message.siteUrl;
    }
    if (message.logsRetentionSec !== undefined && message.logsRetentionSec !== 0) {
      obj.logsRetentionSec = Math.round(message.logsRetentionSec);
    }
    if (message.backupIntervalSec !== undefined && message.backupIntervalSec !== 0) {
      obj.backupIntervalSec = Math.round(message.backupIntervalSec);
    }
    if (message.s3StorageConfig !== undefined) {
      obj.s3StorageConfig = S3StorageConfig.toJSON(message.s3StorageConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerConfig>, I>>(base?: I): ServerConfig {
    return ServerConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerConfig>, I>>(object: I): ServerConfig {
    const message = createBaseServerConfig();
    message.applicationName = object.applicationName ?? "";
    message.siteUrl = object.siteUrl ?? "";
    message.logsRetentionSec = object.logsRetentionSec ?? 0;
    message.backupIntervalSec = object.backupIntervalSec ?? 0;
    message.s3StorageConfig = (object.s3StorageConfig !== undefined && object.s3StorageConfig !== null)
      ? S3StorageConfig.fromPartial(object.s3StorageConfig)
      : undefined;
    return message;
  },
};

function createBaseSystemCronJob(): SystemCronJob {
  return {};
}

export const SystemCronJob: MessageFns<SystemCronJob> = {
  encode(message: SystemCronJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined && message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.spec !== undefined && message.spec !== "") {
      writer.uint32(18).string(message.spec);
    }
    if (message.disableJob !== undefined && message.disableJob !== false) {
      writer.uint32(24).bool(message.disableJob);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SystemCronJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSystemCronJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.spec = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.disableJob = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SystemCronJob {
    return {
      id: isSet(object.id) ? systemCronJobIdFromJSON(object.id) : undefined,
      spec: isSet(object.spec) ? globalThis.String(object.spec) : undefined,
      disableJob: isSet(object.disableJob) ? globalThis.Boolean(object.disableJob) : undefined,
    };
  },

  toJSON(message: SystemCronJob): unknown {
    const obj: any = {};
    if (message.id !== undefined && message.id !== 0) {
      obj.id = systemCronJobIdToJSON(message.id);
    }
    if (message.spec !== undefined && message.spec !== "") {
      obj.spec = message.spec;
    }
    if (message.disableJob !== undefined && message.disableJob !== false) {
      obj.disableJob = message.disableJob;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SystemCronJob>, I>>(base?: I): SystemCronJob {
    return SystemCronJob.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SystemCronJob>, I>>(object: I): SystemCronJob {
    const message = createBaseSystemCronJob();
    message.id = object.id ?? 0;
    message.spec = object.spec ?? "";
    message.disableJob = object.disableJob ?? false;
    return message;
  },
};

function createBaseCronConfig(): CronConfig {
  return { systemJobs: [] };
}

export const CronConfig: MessageFns<CronConfig> = {
  encode(message: CronConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.systemJobs) {
      SystemCronJob.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CronConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCronConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.systemJobs.push(SystemCronJob.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CronConfig {
    return {
      systemJobs: globalThis.Array.isArray(object?.systemJobs)
        ? object.systemJobs.map((e: any) => SystemCronJob.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CronConfig): unknown {
    const obj: any = {};
    if (message.systemJobs?.length) {
      obj.systemJobs = message.systemJobs.map((e) => SystemCronJob.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CronConfig>, I>>(base?: I): CronConfig {
    return CronConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CronConfig>, I>>(object: I): CronConfig {
    const message = createBaseCronConfig();
    message.systemJobs = object.systemJobs?.map((e) => SystemCronJob.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRecordApiConfig(): RecordApiConfig {
  return { aclWorld: [], aclAuthenticated: [], expand: [] };
}

export const RecordApiConfig: MessageFns<RecordApiConfig> = {
  encode(message: RecordApiConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.tableName !== undefined && message.tableName !== "") {
      writer.uint32(18).string(message.tableName);
    }
    if (message.conflictResolution !== undefined && message.conflictResolution !== 0) {
      writer.uint32(40).int32(message.conflictResolution);
    }
    if (message.autofillMissingUserIdColumns !== undefined && message.autofillMissingUserIdColumns !== false) {
      writer.uint32(48).bool(message.autofillMissingUserIdColumns);
    }
    if (message.enableSubscriptions !== undefined && message.enableSubscriptions !== false) {
      writer.uint32(72).bool(message.enableSubscriptions);
    }
    writer.uint32(58).fork();
    for (const v of message.aclWorld) {
      writer.int32(v);
    }
    writer.join();
    writer.uint32(66).fork();
    for (const v of message.aclAuthenticated) {
      writer.int32(v);
    }
    writer.join();
    if (message.createAccessRule !== undefined && message.createAccessRule !== "") {
      writer.uint32(90).string(message.createAccessRule);
    }
    if (message.readAccessRule !== undefined && message.readAccessRule !== "") {
      writer.uint32(98).string(message.readAccessRule);
    }
    if (message.updateAccessRule !== undefined && message.updateAccessRule !== "") {
      writer.uint32(106).string(message.updateAccessRule);
    }
    if (message.deleteAccessRule !== undefined && message.deleteAccessRule !== "") {
      writer.uint32(114).string(message.deleteAccessRule);
    }
    if (message.schemaAccessRule !== undefined && message.schemaAccessRule !== "") {
      writer.uint32(122).string(message.schemaAccessRule);
    }
    for (const v of message.expand) {
      writer.uint32(170).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecordApiConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecordApiConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tableName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.conflictResolution = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.autofillMissingUserIdColumns = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.enableSubscriptions = reader.bool();
          continue;
        }
        case 7: {
          if (tag === 56) {
            message.aclWorld.push(reader.int32() as any);

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.aclWorld.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag === 64) {
            message.aclAuthenticated.push(reader.int32() as any);

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.aclAuthenticated.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.createAccessRule = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.readAccessRule = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.updateAccessRule = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.deleteAccessRule = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.schemaAccessRule = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.expand.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecordApiConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      tableName: isSet(object.tableName) ? globalThis.String(object.tableName) : undefined,
      conflictResolution: isSet(object.conflictResolution)
        ? conflictResolutionStrategyFromJSON(object.conflictResolution)
        : undefined,
      autofillMissingUserIdColumns: isSet(object.autofillMissingUserIdColumns)
        ? globalThis.Boolean(object.autofillMissingUserIdColumns)
        : undefined,
      enableSubscriptions: isSet(object.enableSubscriptions)
        ? globalThis.Boolean(object.enableSubscriptions)
        : undefined,
      aclWorld: globalThis.Array.isArray(object?.aclWorld)
        ? object.aclWorld.map((e: any) => permissionFlagFromJSON(e))
        : [],
      aclAuthenticated: globalThis.Array.isArray(object?.aclAuthenticated)
        ? object.aclAuthenticated.map((e: any) => permissionFlagFromJSON(e))
        : [],
      createAccessRule: isSet(object.createAccessRule) ? globalThis.String(object.createAccessRule) : undefined,
      readAccessRule: isSet(object.readAccessRule) ? globalThis.String(object.readAccessRule) : undefined,
      updateAccessRule: isSet(object.updateAccessRule) ? globalThis.String(object.updateAccessRule) : undefined,
      deleteAccessRule: isSet(object.deleteAccessRule) ? globalThis.String(object.deleteAccessRule) : undefined,
      schemaAccessRule: isSet(object.schemaAccessRule) ? globalThis.String(object.schemaAccessRule) : undefined,
      expand: globalThis.Array.isArray(object?.expand) ? object.expand.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: RecordApiConfig): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.tableName !== undefined && message.tableName !== "") {
      obj.tableName = message.tableName;
    }
    if (message.conflictResolution !== undefined && message.conflictResolution !== 0) {
      obj.conflictResolution = conflictResolutionStrategyToJSON(message.conflictResolution);
    }
    if (message.autofillMissingUserIdColumns !== undefined && message.autofillMissingUserIdColumns !== false) {
      obj.autofillMissingUserIdColumns = message.autofillMissingUserIdColumns;
    }
    if (message.enableSubscriptions !== undefined && message.enableSubscriptions !== false) {
      obj.enableSubscriptions = message.enableSubscriptions;
    }
    if (message.aclWorld?.length) {
      obj.aclWorld = message.aclWorld.map((e) => permissionFlagToJSON(e));
    }
    if (message.aclAuthenticated?.length) {
      obj.aclAuthenticated = message.aclAuthenticated.map((e) => permissionFlagToJSON(e));
    }
    if (message.createAccessRule !== undefined && message.createAccessRule !== "") {
      obj.createAccessRule = message.createAccessRule;
    }
    if (message.readAccessRule !== undefined && message.readAccessRule !== "") {
      obj.readAccessRule = message.readAccessRule;
    }
    if (message.updateAccessRule !== undefined && message.updateAccessRule !== "") {
      obj.updateAccessRule = message.updateAccessRule;
    }
    if (message.deleteAccessRule !== undefined && message.deleteAccessRule !== "") {
      obj.deleteAccessRule = message.deleteAccessRule;
    }
    if (message.schemaAccessRule !== undefined && message.schemaAccessRule !== "") {
      obj.schemaAccessRule = message.schemaAccessRule;
    }
    if (message.expand?.length) {
      obj.expand = message.expand;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RecordApiConfig>, I>>(base?: I): RecordApiConfig {
    return RecordApiConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RecordApiConfig>, I>>(object: I): RecordApiConfig {
    const message = createBaseRecordApiConfig();
    message.name = object.name ?? "";
    message.tableName = object.tableName ?? "";
    message.conflictResolution = object.conflictResolution ?? 0;
    message.autofillMissingUserIdColumns = object.autofillMissingUserIdColumns ?? false;
    message.enableSubscriptions = object.enableSubscriptions ?? false;
    message.aclWorld = object.aclWorld?.map((e) => e) || [];
    message.aclAuthenticated = object.aclAuthenticated?.map((e) => e) || [];
    message.createAccessRule = object.createAccessRule ?? "";
    message.readAccessRule = object.readAccessRule ?? "";
    message.updateAccessRule = object.updateAccessRule ?? "";
    message.deleteAccessRule = object.deleteAccessRule ?? "";
    message.schemaAccessRule = object.schemaAccessRule ?? "";
    message.expand = object.expand?.map((e) => e) || [];
    return message;
  },
};

function createBaseJsonSchemaConfig(): JsonSchemaConfig {
  return {};
}

export const JsonSchemaConfig: MessageFns<JsonSchemaConfig> = {
  encode(message: JsonSchemaConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined && message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.schema !== undefined && message.schema !== "") {
      writer.uint32(18).string(message.schema);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JsonSchemaConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJsonSchemaConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JsonSchemaConfig {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      schema: isSet(object.schema) ? globalThis.String(object.schema) : undefined,
    };
  },

  toJSON(message: JsonSchemaConfig): unknown {
    const obj: any = {};
    if (message.name !== undefined && message.name !== "") {
      obj.name = message.name;
    }
    if (message.schema !== undefined && message.schema !== "") {
      obj.schema = message.schema;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JsonSchemaConfig>, I>>(base?: I): JsonSchemaConfig {
    return JsonSchemaConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JsonSchemaConfig>, I>>(object: I): JsonSchemaConfig {
    const message = createBaseJsonSchemaConfig();
    message.name = object.name ?? "";
    message.schema = object.schema ?? "";
    return message;
  },
};

function createBaseConfig(): Config {
  return { email: undefined, server: undefined, auth: undefined, cron: undefined, recordApis: [], schemas: [] };
}

export const Config: MessageFns<Config> = {
  encode(message: Config, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.email !== undefined) {
      EmailConfig.encode(message.email, writer.uint32(18).fork()).join();
    }
    if (message.server !== undefined) {
      ServerConfig.encode(message.server, writer.uint32(26).fork()).join();
    }
    if (message.auth !== undefined) {
      AuthConfig.encode(message.auth, writer.uint32(34).fork()).join();
    }
    if (message.cron !== undefined) {
      CronConfig.encode(message.cron, writer.uint32(42).fork()).join();
    }
    for (const v of message.recordApis) {
      RecordApiConfig.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.schemas) {
      JsonSchemaConfig.encode(v!, writer.uint32(170).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Config {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = EmailConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.server = ServerConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.auth = AuthConfig.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cron = CronConfig.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.recordApis.push(RecordApiConfig.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.schemas.push(JsonSchemaConfig.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Config {
    return {
      email: isSet(object.email) ? EmailConfig.fromJSON(object.email) : undefined,
      server: isSet(object.server) ? ServerConfig.fromJSON(object.server) : undefined,
      auth: isSet(object.auth) ? AuthConfig.fromJSON(object.auth) : undefined,
      cron: isSet(object.cron) ? CronConfig.fromJSON(object.cron) : undefined,
      recordApis: globalThis.Array.isArray(object?.recordApis)
        ? object.recordApis.map((e: any) => RecordApiConfig.fromJSON(e))
        : [],
      schemas: globalThis.Array.isArray(object?.schemas)
        ? object.schemas.map((e: any) => JsonSchemaConfig.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Config): unknown {
    const obj: any = {};
    if (message.email !== undefined) {
      obj.email = EmailConfig.toJSON(message.email);
    }
    if (message.server !== undefined) {
      obj.server = ServerConfig.toJSON(message.server);
    }
    if (message.auth !== undefined) {
      obj.auth = AuthConfig.toJSON(message.auth);
    }
    if (message.cron !== undefined) {
      obj.cron = CronConfig.toJSON(message.cron);
    }
    if (message.recordApis?.length) {
      obj.recordApis = message.recordApis.map((e) => RecordApiConfig.toJSON(e));
    }
    if (message.schemas?.length) {
      obj.schemas = message.schemas.map((e) => JsonSchemaConfig.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Config>, I>>(base?: I): Config {
    return Config.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Config>, I>>(object: I): Config {
    const message = createBaseConfig();
    message.email = (object.email !== undefined && object.email !== null)
      ? EmailConfig.fromPartial(object.email)
      : undefined;
    message.server = (object.server !== undefined && object.server !== null)
      ? ServerConfig.fromPartial(object.server)
      : undefined;
    message.auth = (object.auth !== undefined && object.auth !== null)
      ? AuthConfig.fromPartial(object.auth)
      : undefined;
    message.cron = (object.cron !== undefined && object.cron !== null)
      ? CronConfig.fromPartial(object.cron)
      : undefined;
    message.recordApis = object.recordApis?.map((e) => RecordApiConfig.fromPartial(e)) || [];
    message.schemas = object.schemas?.map((e) => JsonSchemaConfig.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
